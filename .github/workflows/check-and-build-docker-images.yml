name: Check and Build Docker Images (by Copilot)

on:
  workflow_call:
    inputs:
      base-image:
        description: 'Base image to check'
        required: true
        type: string
      derived-image-prefix:
        description: 'Prefix for the derived image (e.g. ghcr.io/org/repo)'
        required: true
        type: string
      versions:
        description: 'JSON array of versions/tags to check'
        required: true
        type: string
      type:
        description: 'JSON array of image type to check'
        required: false
        type: string
        default: '[""]'
      derived-image-repo:
        description: 'Github repo name (e.g. Neomediatech/rspamd)'
        required: false
        type: string
      derived-image-repo-ref:
        description: 'Github repo ref (e.g. "main" or "master")'
        required: false
        type: string
        default: "main"
      update-image:
        description: 'Whether to update the image or not (e.g. true or false)'
        required: false
        type: string
        default: "false"
      build-test-image:
        description: 'Whether to build a test image or not (e.g. true or false)'
        required: false
        type: string
        default: "false"
      force-build:
        description: 'Whether to force the image build (true or false)'
        required: false
        type: string
        default: "false"
      package-name:
        description: 'The name for the package to build (e.g. neomediatech/rspamd)'
        required: false
        type: string
        default: "default"
    secrets:
      NOTIFY_CMD:
        required: true
      NOTIFY_UP:
        required: true
      NOTIFY_ENDPOINT:
        required: true
      NOTIFY_OPTIONS:
        required: true
      GHCR_TOKEN:
        required: true
      API_TOKEN_GITHUB:
        required: true

permissions:
  contents: write
  packages: write

jobs:
  check-and-build:
    #runs-on: ubuntu-latest
    runs-on: [self-hosted]
    strategy:
      matrix:
        version: ${{ fromJson(inputs.versions) }}
        type: ${{ fromJson(inputs.type) }}
      max-parallel: 1
    env:
      MASTER_REPO: "Neomediatech/gh-workflows.git"
    outputs:
      build-result: ${{ steps.vars.outputs.build_result }}
      report-name: ${{ steps.final-vars.outputs.report_name }}
      image-update-result: ${{ steps.final-vars.outputs.image_update_result }}
      image-name: ${{ steps.final-vars.outputs.image_name }}
    steps:
      # Checkout il repo di questo workflow (utile se hai file di supporto qui)
      - name: Checkout this workflow repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.MASTER_REPO }}
          ref: main
          path: workflow
          token: ${{ secrets.API_TOKEN_GITHUB }}

      # Checkout il repository chiamante (serve per la build se il Dockerfile/context sono lÃ¬)
      - name: Checkout calling repository
        uses: actions/checkout@v4
        with:
          repository: ${{ inputs.derived-image-repo }}
          ref: ${{ inputs.derived-image-repo-ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          path: calling
        if: ${{ inputs.derived-image-repo != '' && inputs.derived-image-repo != null }}

      # Set some var
      - name: Set some var
        id: set-vars
        run: |
          [[ "${{ inputs.build-test-image }}" == "true" ]] && TAG_TEST="-test" || TAG_TEST=""
          echo "TAG_TEST=$TAG_TEST" >> $GITHUB_ENV
          
          [[ "${{ matrix.type }}" == "" ]] && IMAGE_TYPE="" || IMAGE_TYPE="-${{ matrix.type }}"
          echo "IMAGE_TYPE=$IMAGE_TYPE" >> $GITHUB_ENV
          
          if [[ "${{ inputs.base-image }}" =~ ":" ]]; then
            BASE_IMAGE="${{ inputs.base-image }}$IMAGE_TYPE"
          else
            BASE_IMAGE="${{ inputs.base-image }}:${{ matrix.version }}$IMAGE_TYPE"
          fi
          echo "BASE_IMAGE=$BASE_IMAGE" >> $GITHUB_ENV
          
          DERIVED_IMAGE="${{ inputs.derived-image-prefix }}:${{ matrix.version }}$IMAGE_TYPE$TAG_TEST"
          echo "DERIVED_IMAGE=$DERIVED_IMAGE" >> $GITHUB_ENV

          REPO_NAME="$(echo "${{ inputs.derived-image-prefix }}"|sed 's|ghcr.io/||' | awk -F'/' '{print $2}')"      
          echo "BUILD_RESULT=unknown" >> $GITHUB_ENV
          echo "IMAGE_UPDATE_RESULT=unknown" >> $GITHUB_ENV
          echo "DOCKER_IMAGE=none" >> $GITHUB_ENV
          echo "IMAGE_BUILD_NEEDED=true" >> $GITHUB_ENV
          echo "REPO_NAME=$REPO_NAME" >> $GITHUB_ENV
          echo "REPORT_NAME=${REPO_NAME}_${{ matrix.version }}${IMAGE_TYPE}_report.txt" >> $GITHUB_ENV

          # recupero il primo elemento dell'array "versions"
          FIRST_VERSION=$(echo '${{ inputs.versions }}' | jq -r '.[0]')
          echo "FIRST_VERSION=$FIRST_VERSION" >> $GITHUB_ENV

          # recupero il primo elemento dell'array "type"
          FIRST_TYPE=$(echo '${{ inputs.type }}' | jq -r '.[0]')
          echo "FIRST_TYPE=$FIRST_TYPE" >> $GITHUB_ENV

      # Step di verifica aggiornamento immagine
      - name: Check if derived image needs update
        id: check
        run: |
          echo "Controllo digest per $BASE_IMAGE e $DERIVED_IMAGE"

          BASE_DIGEST=$(skopeo inspect docker://$BASE_IMAGE | jq -r '.Digest')
          #DERIVED_DIGEST=$(skopeo inspect docker://$DERIVED_IMAGE | jq -r '.Digest' || echo "")
          DERIVED_DIGEST=$(skopeo inspect docker://$DERIVED_IMAGE | jq -r '.Labels."org.opencontainers.image.base.digest"' || echo "")

          echo "Base digest: $BASE_DIGEST"
          echo "Derived digest: $DERIVED_DIGEST"
          echo "base_image_digest=$BASE_DIGEST" >> $GITHUB_OUTPUT

          if [[ -z "$DERIVED_DIGEST" || "$DERIVED_DIGEST" == "null" ]]; then
            echo "Derived image not found or not accessible, needs build."
            #echo "needs_build=true" >> $GITHUB_OUTPUT
            echo "IMAGE_BUILD_NEEDED=true" >> $GITHUB_ENV
          elif [[ "$BASE_DIGEST" != "$DERIVED_DIGEST" ]]; then
            echo "::notice::Base and derived digests do not match, needs build."
            #echo "needs_build=true" >> $GITHUB_OUTPUT
            echo "IMAGE_BUILD_NEEDED=true" >> $GITHUB_ENV
          else
            echo "::notice::Image up to date."
            #echo "needs_build=false" >> $GITHUB_OUTPUT
            echo "IMAGE_BUILD_NEEDED=false" >> $GITHUB_ENV
          fi

          if [[ ${{ inputs.force-build }} == "true" ]]; then
            echo "::notice::Force build by user (force-build = ${{ inputs.force-build }})"
            #echo "needs_build=true" >> $GITHUB_OUTPUT
            echo "IMAGE_BUILD_NEEDED=true" >> $GITHUB_ENV
          fi

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}
          #password: ${{ secrets.GITHUB_TOKEN }}

      # Notifica l'esistenza di un aggiornamento nel caso si decida di non aggiornare l'immagine
      - name: Notify update needed
        id: only-notify
        run: |
          echo "::notice::Base ($BASE_IMAGE) and derived ($DERIVED_IMAGE) digests do not match, needs build."
          #echo "image_update_result=needed" >> $GITHUB_OUTPUT
          echo "IMAGE_UPDATE_RESULT=needed" >> $GITHUB_ENV
          echo "BUILD_RESULT=needed" >> $GITHUB_ENV
        #if: steps.check.outputs.needs_build == 'true' && inputs.update-image != 'true'
        if: env.IMAGE_BUILD_NEEDED == 'true' && inputs.update-image != 'true'

      # Build e push SOLO se serve aggiornare
      - name: Build and push Docker image
        id: vars
        if: env.IMAGE_BUILD_NEEDED == 'true' && inputs.update-image == 'true'
        run: |
          [[ "${{ inputs.build-test-image }}" == "true" ]] && TAG_TEST="-test" || TAG_TEST=""
          if [[ "${{ matrix.type }}" == "" ]]; then
            IMAGE_TYPE=""
            DOCKERDIR="."
          else
            IMAGE_TYPE="-${{ matrix.type }}"
            DOCKERDIR="${{ matrix.type }}"
          fi
          PACKAGE_NAME="${{ inputs.package-name }}"
          if [[ "$PACKAGE_NAME" != "default" && -n "$PACKAGE_NAME" ]]; then
            DERIVED_IMAGE="ghcr.io/$PACKAGE_NAME:${{ matrix.version }}$IMAGE_TYPE$TAG_TEST"
          else
            DERIVED_IMAGE="${{ inputs.derived-image-prefix }}:${{ matrix.version }}$IMAGE_TYPE$TAG_TEST"
          fi
          echo "Building and pushing $DERIVED_IMAGE"
          cd calling
          if [[ "${{ inputs.base-image }}" =~ ":" ]]; then
            BASE_IMAGE="${{ inputs.base-image }}$IMAGE_TYPE"
          else
            BASE_IMAGE="${{ inputs.base-image }}:${{ matrix.version }}$IMAGE_TYPE"
          fi          
          docker build --pull --label "org.opencontainers.image.base.digest=${{ steps.check.outputs.base_image_digest }}" \
            --label "org.opencontainers.image.base=$BASE_IMAGE" \
            -t $DERIVED_IMAGE -f $DOCKERDIR/Dockerfile.${{ matrix.version }} $DOCKERDIR/
          docker push $DERIVED_IMAGE
          #REPO_NAME=$(echo "${{ inputs.derived-image-prefix }}"|sed 's|ghcr.io/||' | awk -F'/' '{print $2}')
          # update report file
          cd ../calling
          # per utilizzare il workflow comune:
          #cd ../workflow
          REPORT_FILE="update-report.txt"
          echo "::notice::Updating report file $REPORT_FILE"
          echo "$(date) --- $DERIVED_IMAGE UPDATED" >> $REPORT_FILE
          
          echo "build_result=$(date) --- $DERIVED_IMAGE UPDATED" >> $GITHUB_OUTPUT
          echo "BUILD_RESULT=UPDATED" >> $GITHUB_ENV
          #echo "image_update_result=done" >> $GITHUB_OUTPUT
          echo "IMAGE_UPDATE_RESULT=done" >> $GITHUB_ENV
          git config user.name "neo-github-actions[bot]"
          git config user.email "neo-github-actions[bot]@users.noreply.github.com"
          echo "::notice::Local branch:"
          git branch
          echo "::notice::Remote branch:"
          git ls-remote --heads origin
          # per puntare al master repo
          #git remote set-url origin https://x-access-token:${{ secrets.API_TOKEN_GITHUB }}@github.com/${{ env.MASTER_REPO }}
          git add $REPORT_FILE
          git commit -m "Update $DERIVED_IMAGE from ${{ github.repository }} - $(date)"
          #git push origin main
          git push origin ${{ github.ref_name }}

      # Notifica che l'immagine non viene aggiornata perchÃ© sÃ¬ Ã¨ impostata la variabile update-image a 'false'
      - name: Skip image update because user chosen to not update it
        id: update-not-wanted
        if: inputs.update-image != 'true'
        run: |
          echo "NOT updating image because update-image = ${{ inputs.update-image }}"
          #echo "image_update_result=user-said-no" >> $GITHUB_OUTPUT
          echo "IMAGE_UPDATE_RESULT=user-said-no" >> $GITHUB_ENV
          echo "BUILD_RESULT=user-said-no" >> $GITHUB_ENV

      # Notifica che l'immagine non viene aggiornata perchÃ© l'immagine di base Ã¨ giÃ  aggiornata'
      - name: Skip image update because base image is updated
        id: update-not-needed
        if: env.IMAGE_BUILD_NEEDED != 'true'
        run: |
          echo "NOT updating image because base image is updated (IMAGE_BUILD_NEEDED = $IMAGE_BUILD_NEEDED)"
          #echo "image_update_result=not-needed" >> $GITHUB_OUTPUT
          echo "IMAGE_UPDATE_RESULT=not-needed" >> $GITHUB_ENV
          echo "BUILD_RESULT=not-needed" >> $GITHUB_ENV

      - name: Set some result vars
        id: final-vars
        run: |
          echo "image_update_result=$IMAGE_UPDATE_RESULT" >> "$GITHUB_OUTPUT"
          echo "IMAGE_UPDATE_RESULT=$IMAGE_UPDATE_RESULT"
          echo "report_name=${REPO_NAME}_${{ matrix.version }}${IMAGE_TYPE}_report.txt" >> $GITHUB_OUTPUT
          #echo "image_name=${REPO_NAME}_${{ matrix.version }}$IMAGE_TYPE" >> $GITHUB_OUTPUT
          echo "image_name=${REPO_NAME}" >> $GITHUB_OUTPUT

      - name: Push report
        id: final-report
        run: |
          # update report file
          cd calling
          # compilo il report per tutte le immagini. se siamo al primo ciclo, sovrascrivo il contenuto del file
          LAST_REPORT_FILE="last-update-report.txt"
          if [[ "${FIRST_VERSION}-${FIRST_TYPE}" = "${{ matrix.version }}-${{ matrix.type }}" ]]; then
            echo "$(date) --- $DERIVED_IMAGE $BUILD_RESULT (image build needed: $IMAGE_BUILD_NEEDED)" > $LAST_REPORT_FILE
          else
            echo "$(date) --- $DERIVED_IMAGE $BUILD_RESULT (image build needed: $IMAGE_BUILD_NEEDED)" >> $LAST_REPORT_FILE
          fi
          git config user.name "neo-github-actions[bot]"
          git config user.email "neo-github-actions[bot]@users.noreply.github.com"
          echo "::notice::Local branch:"
          git branch
          echo "::notice::Remote branch:"
          git ls-remote --heads origin
          git add $LAST_REPORT_FILE
          git commit -m "Update $DERIVED_IMAGE from ${{ github.repository }} - $(date)"
          git push origin ${{ github.ref_name }}
          echo "last-update-report.txt content:"
          cat last-update-report.txt

      # Docker logout (opzionale, buono per pulizia)
      - name: Docker logout
        run: docker logout ghcr.io
  
  notify:
    needs: [check-and-build]
    uses: Neomediatech/gh-workflows/.github/workflows/notify.yml@main
    permissions:
      contents: write
      packages: write
      actions: write
    with:
      build-result: "${{needs.check-and-build.outputs.build-result}}"
      report-name: "${{needs.check-and-build.outputs.report-name}}"
      image-update-result: "${{needs.check-and-build.outputs.image-update-result}}"
      docker_image: "${{needs.check-and-build.outputs.image-name}}"
    secrets:
      NOTIFY_CMD: ${{ secrets.NOTIFY_CMD }}
      NOTIFY_UP: ${{ secrets.NOTIFY_UP }}
      NOTIFY_ENDPOINT: ${{ secrets.NOTIFY_ENDPOINT }}
      NOTIFY_OPTIONS: ${{ secrets.NOTIFY_OPTIONS }}
      GHCR_TOKEN: ${{ secrets.GHCR_TOKEN }}
      API_TOKEN_GITHUB: ${{ secrets.API_TOKEN_GITHUB }}
