name: Check Base Image Updates

on:
  #schedule:
    # Esegui ogni giorno alle 04:00 UTC per controllare gli aggiornamenti.
  #  - cron: '0 4 * * *'
  workflow_dispatch:

jobs:
  check:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write

    strategy:
      matrix:
        #type: [apache, fpm]
        version: [latest, 24.04, 22.04, 20.04, 18.04]
      max-parallel: 1
      #fail-fast: false # Continua a eseguire gli altri job della matrice anche se uno fallisce

    #name: Check ${{ matrix.type }}:${{ matrix.version }} updates
    name: Check ${{ matrix.version }} updates
    
    steps:
      - name: Set up Docker Buildx
        # Questo step è utile per configurare l'ambiente Docker e può essere utile
        # se in futuro aggiungerai step di build multi-arch.
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        # Anche per immagini pubbliche, il login con GITHUB_TOKEN può aiutare a evitare
        # limiti di rate e garantisce un accesso più robusto.
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }} # Token fornito automaticamente da GitHub Actions

      #- name: Check image digests for ${{ matrix.type }}:${{ matrix.version }}
      - name: Check image digests for ${{ matrix.version }}
        id: check_digests # Assegniamo un ID a questo step per poter accedere ai suoi output
        run: |
          # Costruisci i nomi completi delle immagini usando le variabili della matrice
          BASE_IMAGE="ubuntu:${{ matrix.version }}"
          #DERIVED_IMAGE="ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }}"
          DERIVED_IMAGE="ghcr.io/neomediatech/ubuntu-base:${{ matrix.version }}"

          echo "Checking updates for: $DERIVED_IMAGE based on $BASE_IMAGE"

          # if docker < v25.0.0
          # Recupera il digest dell'immagine base da Docker Hub
          # L'output di 'docker manifest inspect' senza --json è testuale.
          # Cerchiamo la riga "Digest:" e prendiamo il secondo campo.
          BASE_DIGEST=$(docker manifest inspect "$BASE_IMAGE" 2>&1 | grep 'Digest:' | head -n1 | awk '{print $2}')

          if [ -z "$BASE_DIGEST" ]; then # Verifica se il digest è vuoto
            echo "::error::Failed to get digest for base image: $BASE_IMAGE"
            docker manifest inspect "$BASE_IMAGE" # Mostra l'output completo per debugging
            exit 1
          fi
          echo "Base Image Digest ($BASE_IMAGE): $BASE_DIGEST"

          # Recupera il digest dell'immagine derivata da GHCR
          DERIVED_DIGEST=$(docker manifest inspect "$DERIVED_IMAGE" 2>&1 | grep 'Digest:' | head -n1 | awk '{print $2}')

          if [ -z "$DERIVED_DIGEST" ]; then # Verifica se il digest è vuoto
            echo "::error::Failed to get digest for derived image: $DERIVED_IMAGE"
            docker manifest inspect "$DERIVED_IMAGE" # Mostra l'output completo per debugging
            exit 1
          fi
          echo "Derived Image Digest ($DERIVED_IMAGE): $DERIVED_DIGEST"

          # if docker > v25.0.0
          # Recupera il digest dell'immagine base da Docker Hub
          # Usiamo 'jq' per parsare l'output JSON in modo robusto, gestendo sia manifest singoli che liste di manifest.
          # `.[0].Digest // .Digest` cerca il digest nel primo elemento di un array (per manifest list)
          # o direttamente nel campo 'Digest' (per manifest singoli).
          #BASE_MANIFEST_JSON=$(docker manifest inspect "$BASE_IMAGE" --json)
          #if [ $? -ne 0 ]; then
          #  echo "::error::Failed to inspect base image: $BASE_IMAGE"
          #  exit 1 # Fallisce lo step se l'ispezione dell'immagine base fallisce
          #fi
          #BASE_DIGEST=$(echo "$BASE_MANIFEST_JSON" | jq -r '.[0].Digest // .Digest')

          #echo "Base Image Digest ($BASE_IMAGE): $BASE_DIGEST"

          # Recupera il digest dell'immagine derivata da GHCR
          #DERIVED_MANIFEST_JSON=$(docker manifest inspect "$DERIVED_IMAGE" --json)
          #if [ $? -ne 0 ]; then
          #  echo "::error::Failed to inspect derived image: $DERIVED_IMAGE"
            # Se l'immagine derivata non esiste o non è accessibile, consideriamo che necessita di aggiornamento
            # o almeno che non è stata trovata, quindi si può forzare un rebuild.
            # Puoi scegliere se far fallire il workflow qui o continuare e segnalare un aggiornamento necessario.
            # Per ora, lo faremo fallire per chiarezza.
          #  exit 1
          #fi
          #DERIVED_DIGEST=$(echo "$DERIVED_MANIFEST_JSON" | jq -r '.[0].Digest // .Digest')

          #echo "Derived Image Digest ($DERIVED_IMAGE): $DERIVED_DIGEST"

          # Confronta i digest
          if [ "$DERIVED_DIGEST" != "$BASE_DIGEST" ]; then
            echo "::notice file=README.md::The base image ($BASE_IMAGE) has been updated! Rebuild $DERIVED_IMAGE."
            echo "needs-updating=true" >> "$GITHUB_OUTPUT"
          else
            echo "The base image ($BASE_IMAGE) has not changed. No rebuild needed for $DERIVED_IMAGE."
            echo "needs-updating=false" >> "$GITHUB_OUTPUT"
          fi
        shell: bash # Assicurati di usare bash per le funzionalità avanzate dello script

      #- name: Perform rebuild and push (if update needed)
        # Questo step verrà eseguito solo se 'needs-updating' è 'true' per questa specifica combinazione della matrice.
      #  if: steps.check_digests.outputs.needs-updating == 'true'
      #  run: |
      #    echo "Starting rebuild process for ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }}"
          # Qui dovresti aggiungere i tuoi comandi per:
          # 1. Fare il checkout del repository che contiene il Dockerfile per questa immagine.
          #    Esempio: uses: actions/checkout@v4
          # 2. Costruire la nuova immagine Docker.
          #    Assicurati che il Dockerfile sia configurato per usare ubuntu:${{ matrix.version }} come base.
          #    Potrebbe essere necessario un Dockerfile dinamico o più Dockerfile.
          #    Esempio: docker build -t ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }} .
          # 3. Pushare la nuova immagine su ghcr.io.
          #    Esempio: docker push ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }}

          # Esempio placeholder (sostituisci con la tua logica di build e push):
      #    echo "Simulating build and push for ${{ matrix.type }}:${{ matrix.version }}"
          # docker build -f path/to/Dockerfile.${{ matrix.type }} \
          #              --build-arg UBUNTU_VERSION=${{ matrix.version }} \
          #              -t ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }} .
          # docker push ghcr.io/neomediatech/ubuntu-${{ matrix.type }}:${{ matrix.version }}
      #  shell: bash

      - name: No update needed message
        if: steps.check_digests.outputs.needs-updating == 'false'
        run: |
          echo "No update needed for ${{ matrix.version }}. Skipping rebuild."
          #echo "No update needed for ${{ matrix.type }}:${{ matrix.version }}. Skipping rebuild."
        shell: bash
