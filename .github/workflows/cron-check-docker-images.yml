name: Check via cron if a image needs to be updated

on:
  #schedule:
  #  - cron: '0 4 * * *'
  workflow_dispatch:
  workflow_call:

jobs:
  prepare-matrix:
    runs-on: [self-hosted]
    outputs:
      matrix: ${{ steps.prepare-data.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Prepare all data for matrix
        id: prepare-data
        run: |
          # Specifica il percorso del tuo file
          FILE="images-to-check.txt"

          # creo un array contenente il repo come indice e il tipo di immagine come valore
          declare -A REPOS
          while IFS=';' read -r REPO IMAGE_TYPE; do
            # Salta le righe vuote o commentate
            if [[ ! -z "$REPO" && ! "$REPO" =~ ^# ]]; then
              # Rimuove gli spazi bianchi iniziali e finali
              REPO=$(echo "$REPO" | xargs)
              IMAGE_TYPE=$(echo "$IMAGE_TYPE" | xargs)

              # Assegna la chiave (REPO) e il valore (IMAGE_TYPE)
              REPOS["$REPO"]="$IMAGE_TYPE"
            fi
          done < "$FILE"

          # creo altri array contenenti gli altri elementi
          declare -A REPO_TAGS
          declare -A BASE_IMAGES
          declare -A PACKAGES
          declare -A IMAGES_TYPE
          for REPO in "${!REPOS[@]}"; do
              echo "::notice:: Retrieving tags for repository: $REPO"
              TAGS=$(skopeo inspect docker://${REPO} | jq -r '.RepoTags[]' || echo "")
              
              # inserisce i tag nell'array indicizzato
              REPO_TAGS["$REPO"]="$TAGS"
              echo "::notice:: TAGS for repo $REPO : $TAGS"

              # processo ogni tag, recupero i metadati e inserisco tutto nei vari array associativi
              for TAG in $TAGS; do
                IMAGE="${REPO}:${TAG}"
                IMAGE_META="$(skopeo inspect docker://${IMAGE} || echo "")"
                BASE_IMAGES["$IMAGE"]="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.image.base"' || echo "")"
                PACKAGES["$IMAGE"]="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.package.name"' || echo "")"
                IMAGES_TYPE["$IMAGE"]="${REPO}"
                echo "::notice:: IMAGE ${IMAGE}, BASE_IMAGE ${BASE_IMAGES[$IMAGE]}, PACKAGE ${PACKAGES[$IMAGE]}, IMAGE_TYPE ${IMAGES_TYPE[$IMAGE]}"
              done
          done

          # 4. Genera la matrice finale per il job successivo.
          #MATRIX_JSON=$(echo "${FINAL_MATRIX_DATA}" | jq -c '{include: .}')
          #echo "matrix=$MATRIX_JSON" >> "$GITHUB_OUTPUT"

  #check-update:
  #  runs-on: [self-hosted]
  #  needs: prepare-matrix
  #  strategy:
  #    matrix:
  #      include: ${{ fromJson(needs.prepare-matrix.outputs.matrix).include }}
  #  steps:
      #- name: Check image update (check software versions)
      #  id: check-image
      #  uses: Neomediatech/gh-workflows/.github/actions/image-type-list@main
      #  with:
      #    image-type: '${{ matrix.image_type }}'
      #    base-image: '${{ matrix.base_image }}'
      #    derived-image: '${{ matrix.image_repo }}'
      #    package-to-check: '${{ matrix.package_name }}'
      #    image-version: '${{ matrix.tag }}'
  #    - name: Test output
  #      run: |
  #        echo "image-type: '${{ matrix.image_type }}'"
  #        echo "base-image: '${{ matrix.base_image }}'"
  #        echo "derived-image: '${{ matrix.image_repo }}'"
  #        echo "package-to-check: '${{ matrix.package_name }}'"
  #        echo "image-version: '${{ matrix.tag }}'"
