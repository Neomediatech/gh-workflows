name: Check via cron if a image needs to be updated

on:
  schedule:
    - cron: '30 4 * * 1'
  workflow_dispatch:
  workflow_call:

jobs:
  prepare-matrix:
    runs-on: [self-hosted]
    outputs:
      matrix: ${{ steps.prepare-data.outputs.matrix }}
      start-date: ${{ steps.prepare-data.outputs.start-date }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GHCR_TOKEN }}

      - name: Log in to Docker Registry
        uses: docker/login-action@v3
        with:
          username: ${{ vars.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Prepare all data for matrix
        id: prepare-data
        run: |
          FILE="images-to-check.txt"
          START_DATE="$(date)"
          echo "start-date=$START_DATE" >> "$GITHUB_OUTPUT"

          # creo un array contenente il repo come indice e il tipo di immagine come valore
          declare -A REPOS
          while IFS=';' read -r REPO IMAGE_TYPE; do
            # Salta le righe vuote o commentate
            if [[ ! -z "$REPO" && ! "$REPO" =~ ^# ]]; then
              # Rimuove gli spazi bianchi iniziali e finali
              REPO=$(echo "$REPO" | xargs)
              IMAGE_TYPE=$(echo "$IMAGE_TYPE" | xargs)

              # Assegna la chiave (REPO) e il valore (IMAGE_TYPE)
              REPOS["$REPO"]="$IMAGE_TYPE"
            fi
          done < "$FILE"

          MATRIX_ARRAY="[]"

          for REPO in "${!REPOS[@]}"; do
              echo "::notice:: Retrieving tags for repository: $REPO"
              TAGS=$(skopeo inspect docker://${REPO} | jq -r '.RepoTags[]' || echo "")

              # processo ogni tag, recupero i metadati e inserisco tutto nel JSON
              for TAG in $TAGS; do
                IMAGE="${REPO}:${TAG}"
                IMAGE_META="$(skopeo inspect docker://${IMAGE} || echo "")"
                BASE_IMAGE="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.image.base" // ""')"
                PACKAGE_VERSION="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.package.version" // ""')"
                IMAGE_TYPE="${REPOS[$REPO]}"
                if [[ "$IMAGE_TYPE" == "meta" ]]; then
                  PACKAGE_NAME="$(basename "$(echo $IMAGE_META |jq -r '.Name + "_VERSION"'|tr '[:lower:]' '[:upper:]')")"
                else
                  PACKAGE_NAME="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.package.name" // ""')"
                fi
                IMAGE_SOURCE="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.image.source" // ""')"
                echo "::notice:: IMAGE ${IMAGE}, BASE_IMAGE ${BASE_IMAGE}, PACKAGE ${PACKAGE_NAME}, IMAGE_TYPE ${IMAGE_TYPE}, PACKAGE_VERSION ${PACKAGE_VERSION}"

                if [[ "$BASE_IMAGE" == "" || "$PACKAGE_VERSION" == "" || "$PACKAGE_NAME" == "" ]]; then
                  echo "::warning:: uno o pi√π parametri non trovati, non inserisco l'elemento nell'array"
                else
                  # Costruisci l'oggetto JSON per l'immagine corrente
                  JSON_ITEM="{\"repo\":\"$REPO\", \"tag\":\"$TAG\", \"base_image\":\"$BASE_IMAGE\", \
                              \"package_name\":\"$PACKAGE_NAME\", \"image_type\":\"$IMAGE_TYPE\", \
                              \"package_version\":\"$PACKAGE_VERSION\", \"image_source\":\"$IMAGE_SOURCE\"}"
                  # Aggiungi l'oggetto all'array
                  if [ "$MATRIX_ARRAY" == "[]" ]; then
                    MATRIX_ARRAY="[$JSON_ITEM]"
                  else
                    MATRIX_ARRAY=$(echo "$MATRIX_ARRAY" | jq -c ". += [$JSON_ITEM]")
                  fi
                  echo "::notice:: Added to matrix: $JSON_ITEM"
                fi
              done
          done

          # Imposta l'output per il prossimo passo
          echo "matrix=$MATRIX_ARRAY" >> "$GITHUB_OUTPUT"

  check-update:
    runs-on: [self-hosted]
    needs: prepare-matrix
    strategy:
      matrix:
        repo: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    steps:
      - name: Info
        run: |
          echo "::notice:: processing ${{ matrix.repo.repo }}:${{ matrix.repo.tag }}, base image ${{ matrix.repo.base_image }}, package to check '${{ matrix.repo.package_name }}', image type '${{ matrix.repo.image_type }}'"

      - name: Check image update (check software versions)
        id: check-image
        uses: Neomediatech/gh-workflows/.github/actions/image-type-list@main
        with:
          image-type: '${{ matrix.repo.image_type }}'
          base-image: '${{ matrix.repo.base_image }}'
          derived-image: '${{ matrix.repo.repo }}:${{ matrix.repo.tag }}'
          package-to-check: '${{ matrix.repo.package_name }}'
          image-version: '${{ matrix.repo.tag }}'

      - name: Set vars after Check
        run: |
          UPDATE_NEEDED=${{ steps.check-image.outputs.update-needed }}
          echo "::notice:: Update Needed: $UPDATE_NEEDED"
          echo "UPDATE_NEEDED=$UPDATE_NEEDED" >> $GITHUB_ENV
          echo "::notice:: Base image package version: ${{ steps.check-image.outputs.base-img-pkg-ver }}"
          echo "BASE_PACKAGE_VERSION=${{ steps.check-image.outputs.base-img-pkg-ver }}" >> $GITHUB_ENV
          echo "::notice:: Derived image package version: ${{ matrix.repo.package_version }}"

          # set update result
          IMAGE_SOURCE_TXT=""
          IMAGE_SOURCE_HTM="</td><td>&nbsp;"
          case "${{ steps.check-image.outputs.update-needed }}" in
            "unknown")
              ICON="‚ùì"
              IMAGE_SOURCE_TXT=" --- image source ${{ matrix.repo.image_source }}"
              IMAGE_SOURCE_HTM="</td><td>image source ${{ matrix.repo.image_source }}"
              ;;
            "false")
              ICON="‚úÖ"
              ;;
            "true")
              ICON="üîÅ"
              IMAGE_SOURCE_TXT=" --- image source ${{ matrix.repo.image_source }}"
              IMAGE_SOURCE_HTM="</td><td>image source ${{ matrix.repo.image_source }}"
              ;;
            "*")
              ICON="‚ö†Ô∏è"
              IMAGE_SOURCE_TXT=" --- image source ${{ matrix.repo.image_source }}"
              IMAGE_SOURCE_HTM="</td><td>image source ${{ matrix.repo.image_source }}"
              ;;
          esac
          echo "$ICON ${{ steps.check-image.outputs.update-needed }}"
          TITLE="$ICON (${{ matrix.repo.repo }})"
          REPO_NAME="$(echo "${{ matrix.repo.repo }}"|sed 's|ghcr.io/||' | awk -F'/' '{print $2}')"
          ARTIFACT_FILE="${REPO_NAME}_${{ matrix.repo.tag }}_report.txt"
          echo "ARTIFACT_FILE=$ARTIFACT_FILE" >> $GITHUB_ENV
          DATE="$(date)"
          mkdir -p reports
          echo "$DATE --- ${{ matrix.repo.repo }}:${{ matrix.repo.tag }} --- Update required: $ICON ${UPDATE_NEEDED}${IMAGE_SOURCE_TXT}" > reports/$ARTIFACT_FILE
          echo "STATUS=$ICON $REPO_NAME" >> reports/$ARTIFACT_FILE
          echo "<tr><td>$DATE</td><td>${{ matrix.repo.repo }}:${{ matrix.repo.tag }}</td><td>Update required: $ICON ${UPDATE_NEEDED}${IMAGE_SOURCE_HTM}</td></tr>" > reports/${ARTIFACT_FILE}.html
          #ls -l

      - name: Upload result
        uses: actions/upload-artifact@v4
        with:
          name: result-${{ strategy.job-index }}
          #path: ${{ env.ARTIFACT_FILE }}
          path: reports/*
          retention-days: 1
          overwrite: true

  build-report:
    needs: [prepare-matrix,check-update]
    runs-on: [self-hosted]
    steps:
      - name: Checkout calling repository
        uses: actions/checkout@v5

      - name: Set some var
        run: |
          echo "REPORT_NAME=image-update-report-${{ github.job }}-${{ github.run_id }}-${{ github.run_number }}" >> $GITHUB_ENV
          rm -rf results reports

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: result-*
          path: results
          merge-multiple: true

      - name: Join reports and commit it
        run: |
          PUSH_FILES=""
          PUSH='false'
          if [[ -d results ]]; then
            GLOBAL_ICON="‚úÖ"
            LAST_UPDATE_REPORT_FILE="update-report-last.txt"
            HISTORY_UPDATE_REPORT_FILE="update-report-history.txt"
            rm -f "$LAST_UPDATE_REPORT_FILE"
            mkdir -p reports
            cd results
            for REPO_NAME in $(ls *_report.txt | sed 's/_.*//g' | sort -u); do
              echo "::notice:: REPO_NAME=$REPO_NAME"
              cat ${REPO_NAME}_*.txt > ../${REPO_NAME}_update-report-last.txt
              cat ${REPO_NAME}_*.txt | sed '/STATUS=/d' | sort >> ../"$LAST_UPDATE_REPORT_FILE"
              cat ${REPO_NAME}_*.txt | sed '/STATUS=/d' | sort >> ../"${HISTORY_UPDATE_REPORT_FILE}"
              ICONS="$(cat ../${REPO_NAME}_update-report-last.txt|grep "STATUS="| sed 's/STATUS=//g'| awk '{print $1}'| xargs)"
              if [[ "$ICONS" == *"‚ùì"* ]]; then
                ICON="‚ùì"
                GLOBAL_ICON=$ICON
              elif [[ "$ICONS" == *"‚ö†Ô∏è"* ]]; then
                ICON="‚ö†Ô∏è"
                if [[ "$GLOBAL_ICON != "‚ùì" ]]; then
                  GLOBAL_ICON=$ICON
                fi
              elif [[ "$ICONS" == *"üîÅ"* ]]; then
                ICON="üîÅ"
                if [[ "$GLOBAL_ICON != "‚ùì" && "$GLOBAL_ICON != "‚ö†Ô∏è" ]]; then
                  GLOBAL_ICON=$ICON
                fi                
              elif [[ "$ICONS" == *"‚úÖ"* ]]; then
                ICON="‚úÖ"
              else
                ICON="‚ö†Ô∏è"
                if [[ "$GLOBAL_ICON != "‚ùì" ]]; then
                  GLOBAL_ICON=$ICON
                fi
              fi
              rm -f ../${REPO_NAME}_update-report-last.txt
            done

            cat *.txt.html |sort > ../update-report-last.html

            cd ..
            TMP_REPORT_FILE="report.txt"
            echo "${{ needs.prepare-matrix.outputs.start-date }} --- Job started" > $TMP_REPORT_FILE
            cat "$LAST_UPDATE_REPORT_FILE" | sort >> $TMP_REPORT_FILE
            DATE="$(date)"
            echo "$DATE --- Job terminated" >> $TMP_REPORT_FILE
            #truncate -s -1 $TMP_REPORT_FILE
            #echo " --- Job terminated" >> $TMP_REPORT_FILE
            cat $TMP_REPORT_FILE | sed 's/$/<br>/g' > reports/body.txt

            HTML_REPORT_FILE="report.html"
            echo '<table border="1">' > $HTML_REPORT_FILE
            echo '<tr><th colspan="4">${{ needs.prepare-matrix.outputs.start-date }} --- Job started</th></tr>' >> $HTML_REPORT_FILE
            cat update-report-last.html | sort >> $HTML_REPORT_FILE
            echo "<tr><td colspan=\"4\">$DATE --- Job terminated</td></tr>" >> $HTML_REPORT_FILE
            echo "</table>" >> $HTML_REPORT_FILE
            echo "Build single image here: \
              <a href=\"https://github.com/Neomediatech/gh-workflows/actions/workflows/build-and-push-single-docker-image.yml\">\
              https://github.com/Neomediatech/gh-workflows/actions/workflows/build-and-push-single-docker-image.yml\
              </a>" >> $HTML_REPORT_FILE
            cat $HTML_REPORT_FILE > reports/body.txt
            
            mv $TMP_REPORT_FILE reports/$LAST_UPDATE_REPORT_FILE
            PUSH_FILES="$LAST_UPDATE_REPORT_FILE ${HISTORY_UPDATE_REPORT_FILE}"
            PUSH='true'
            echo "UPLOAD_REPORT=true" >> $GITHUB_ENV
            echo "ICON=$GLOBAL_ICON" >> $GITHUB_ENV
          fi

          if [[ "$PUSH" == "true" ]]; then
            git config user.name "neo-github-actions[bot]"
            git config user.email "neo-github-actions[bot]@users.noreply.github.com"
            git add $PUSH_FILES
            git commit -m "[bot] Update from ${{ github.workflow_ref }} - $(date)"
            git push origin ${{ github.ref_name }}
          fi

      - name: Upload global report
        uses: actions/upload-artifact@v4
        if: ${{ env.UPLOAD_REPORT == 'true' }}
        with:
          name: ${{ env.REPORT_NAME }}
          path: reports/*.txt
          retention-days: 1
          overwrite: true

      - name: Notify image build
        id: notify
        uses: Neomediatech/gh-workflows/.github/actions/send-notification@main
        if: ${{ env.UPLOAD_REPORT == 'true' }}
        with:
          report-name: ${{ env.REPORT_NAME }}
          title: "${{ env.ICON }} Aggiornamenti immagini docker"
          #message: "${{ env.MESSAGE_BODY }}"
          notify-cmd: ${{ secrets.NOTIFY_CMD }}
          notify-up: ${{ secrets.NOTIFY_UP }}
          notify-endpoint: ${{ secrets.NOTIFY_ENDPOINT }}
          notify-options: ${{ secrets.NOTIFY_OPTIONS }}
