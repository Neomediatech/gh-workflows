name: Check via cron if a image needs to be updated

on:
  #schedule:
  #  - cron: '0 4 * * *'
  workflow_dispatch:
  workflow_call:

jobs:
  prepare-matrix:
    runs-on: [self-hosted]
    outputs:
      matrix: ${{ steps.prepare-data.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Prepare all data for matrix
        id: prepare-data
        run: |
          # Specifica il percorso del tuo file
          FILE="images-to-check.txt"

          # creo un array contenente il repo come indice e il tipo di immagine come valore
          declare -A REPOS
          while IFS=';' read -r REPO IMAGE_TYPE; do
            # Salta le righe vuote o commentate
            if [[ ! -z "$REPO" && ! "$REPO" =~ ^# ]]; then
              # Rimuove gli spazi bianchi iniziali e finali
              REPO=$(echo "$REPO" | xargs)
              IMAGE_TYPE=$(echo "$IMAGE_TYPE" | xargs)

              # Assegna la chiave (REPO) e il valore (IMAGE_TYPE)
              REPOS["$REPO"]="$IMAGE_TYPE"
            fi
          done < "$FILE"

          MATRIX_ARRAY="[]"

          for REPO in "${!REPOS[@]}"; do
              echo "::notice:: Retrieving tags for repository: $REPO"
              TAGS=$(skopeo inspect docker://${REPO} | jq -r '.RepoTags[]' || echo "")

              # processo ogni tag, recupero i metadati e inserisco tutto nel JSON
              for TAG in $TAGS; do
                IMAGE="${REPO}:${TAG}"
                IMAGE_META="$(skopeo inspect docker://${IMAGE} || echo "")"
                BASE_IMAGE="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.image.base" // ""')"
                PACKAGE_NAME="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.package.name" // ""')"
                PACKAGE_VERSION="$(echo "$IMAGE_META" | jq -r '.Labels."org.opencontainers.package.version" // ""')"
                IMAGE_TYPE="${REPOS[$REPO]}"
                echo "::notice:: IMAGE ${IMAGE}, BASE_IMAGE ${BASE_IMAGE}, PACKAGE ${PACKAGE_NAME}, IMAGE_TYPE ${IMAGE_TYPE}, PACKAGE_VERSION ${PACKAGE_VERSION}"

                # Costruisci l'oggetto JSON per l'immagine corrente
                JSON_ITEM="{\"repo\":\"$REPO\", \"tag\":\"$TAG\", \"base_image\":\"$BASE_IMAGE\", \"package_name\":\"$PACKAGE_NAME\", \"image_type\":\"$IMAGE_TYPE\", \"package_version\":\"$PACKAGE_VERSION\"}"
                # Aggiungi l'oggetto all'array
                if [ "$MATRIX_ARRAY" == "[]" ]; then
                  MATRIX_ARRAY="[$JSON_ITEM]"
                else
                  MATRIX_ARRAY=$(echo "$MATRIX_ARRAY" | jq -c ". += [$JSON_ITEM]")
                fi
                echo "::notice:: Added to matrix: $JSON_ITEM"
              done
          done

          # Imposta l'output per il prossimo passo
          echo "matrix=$MATRIX_ARRAY" >> "$GITHUB_OUTPUT"

  check-update:
    runs-on: [self-hosted]
    needs: prepare-matrix
    strategy:
      matrix:
        repo: ${{ fromJson(needs.prepare-matrix.outputs.matrix) }}
    steps:
      - name: Info
        run: |
          echo "::notice:: processing ${{ matrix.repo.repo }} with tag ${{ matrix.repo.tag }}, base image ${{ matrix.repo.base_image }}, package to check '${{ matrix.repo.package_name }}', image type '${{ matrix.repo.image_type }}'"
          #echo "base-image: '${{ matrix.repo.base_image }}'"
          #echo "derived-image: '${{ matrix.repo.repo }}'"
          #echo "package-to-check: '${{ matrix.repo.package_name }}'"
          #echo "image-version: '${{ matrix.repo.tag }}'"

      - name: Check image update (check software versions)
        id: check-image
        uses: Neomediatech/gh-workflows/.github/actions/image-type-list@main
        with:
          image-type: '${{ matrix.repo.image_type }}'
          base-image: '${{ matrix.repo.base_image }}'
          derived-image: '${{ matrix.repo.repo }}'
          package-to-check: '${{ matrix.repo.package_name }}'
          image-version: '${{ matrix.repo.tag }}'

      - name: Set vars from Check image type action
        run: |
          echo "::notice:: Update Needed: ${{ steps.check-image.outputs.update-needed }}"
          echo "UPDATE_NEEDED=${{ steps.check-image.outputs.update-needed }}" >> $GITHUB_ENV
          echo "::notice:: Base image package version: ${{ steps.check-image.outputs.base-img-pkg-ver }}"
          echo "BASE_PACKAGE_VERSION=${{ steps.check-image.outputs.base-img-pkg-ver }}" >> $GITHUB_ENV
          echo "::notice:: Derived image package version: ${{ matrix.repo.package_version }}"

          # set update result
          case "${{ steps.check-image.outputs.update-needed }}" in
            "unknown")
              echo "${{ steps.check-image.outputs.update-needed }}"
              ICON="❓"
              ;;
            "false")
              echo "${{ steps.check-image.outputs.update-needed }}"
              ICON="✅"
              ;;
            "true")
              echo "${{ steps.check-image.outputs.update-needed }}"
              ICON="🔁"
              ;;
            "*")
              echo "${{ steps.check-image.outputs.update-needed }}"
              ICON="⚠️"
              ;;
          esac
          TITLE="$ICON (${{ matrix.repo.repo }})"
          # nuovo report per upload artifact
          #ARTIFACT_FILE="${REPO_NAME}_${{ matrix.version }}${IMAGE_TYPE}_report.txt"
          #echo "ARTIFACT_FILE=$ARTIFACT_FILE" >> $GITHUB_ENV
          #echo "$(date) --- $DERIVED_IMAGE $IMAGE_UPDATE_RESULT (image build needed: $IMAGE_BUILD_NEEDED)" > $ARTIFACT_FILE
          #echo "STATUS=$ICON ${REPO_NAME}" >> $ARTIFACT_FILE
          #ls -l
